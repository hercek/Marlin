/* [wxMaxima batch file version 1] [ DO NOT EDIT BY HAND! ]*/
/* [ Created with wxMaxima version 16.12.2 ] */

/* [wxMaxima: title   start ]
Rostock Calibration
   [wxMaxima: title   end   ] */

/* [wxMaxima: comment start ]
Copyright © 2014 Peter Hercek.
You can use, modify, and redistribute this under GNU GENERAL PUBLIC LICENSE Version 3.
   [wxMaxima: comment end   ] */

/* [wxMaxima: comment start ]
This document helps to find proper values for these firmware parameters: tower positions, diagonal rod length,
and top endstop position offsets. Errors in these firmware parameters can be fixed perfectly provided the
assumptions bellow are valid.
* We assume that the towers are parallel. Ensuring that the towers are parallel is tricky. Drill both top and
bottom plates at once. This ensures top and bottom tower positions are exactly the same. That is the easy
part. Then do not twist top plate with respect to the bottom one. They are not twisted if diagonals have the
same length.
* We assume that all your diagonal rods have the same length (although the common length is not known
precisely). You can easily achieve this with a jig. (Note: If your diagonal rods do not have the same length it will
introduce rotations to your platform. These will not have that big impact on z-height but will have significant
impact on x/y precision.)
* We assume that the bed is perpendicular to the towers. Making sure the bed is perpendicular is harder but
callibration can partially fix it with the top endstop adjustements. This compensation will not be perfect. For
example, if your bed is 1 mm higer on one side (compared to the other side) then this will lead to errors smaller
than about 0.3 mm, possibly much smaller. I did not investigate this in details. This compensation using top
endstops will also lead to your prints being as skewed as your bed is.
* We assume no other auto level is active (e.g. Johann's auto leveling cannot be enabled).
   [wxMaxima: comment end   ] */

/* [wxMaxima: comment start ]
A note on manual leveling (i.e. doing the same as this notebook without running it):
1) level at the tower bases by adjusting endstops
2) level the points at the far end of a tower base (i.e. between the other two towers); these far points
   should be located significantly behind the line connecting the other two virtual tower bases
   * moving tower along bed radius has the biggest z-height impact on the oposite side of the tower
      (if it is symetricaly high/low on the oposite side then you need to move it nearer/further in firmware)
   * moving tower perpendiculary to bed radius has the biggest z-height impact just to the left/right of
     the tower - one side is going up and the other side is going down
     (if e.g. left side is up and right is down then you need to move tower in firmware to the right)
   * if all the points opposite of all towers have the same z-height error then adjust delta radius
      (if they are high/low then you need to decrease/increase delta radius in firmware)
3) level the center by adjusting diagonal rod length or delta radius
    * diagonal rod length: if head is too high/low in the center then you need to increase/decrease the length
    * delta radius: if head is too high/low in the center then you need to increase/decrease delta radius
This manual leveling is very iterative. If you fix something a bit, the fix will have impact on z-heights on
all the other positions. So you must start from the beginning after each fix. It is best to fix the biggest
errors first. If you cannot decide which one is the biggest one then go in the order of the points above.
   [wxMaxima: comment end   ] */

/* [wxMaxima: comment start ]
Lets go back to this math supported approach.
In this document:
* coordinates are refered as x,y,z;
* towers are refered as a,b,c;
* diagonal rod length is r;
* imprecise values (because of incorrect firmware parameters) have prefix i;
* tower carriage position offsets are marked as α, β, γ for towers a, b, c respectively;
* tower carriage positions (coordinates on towers) are ta, tb, tc.
We want to make our coordinate system as fixed as possible. Lets mark (x,y) coordinates of towers (a, b, c) as
xa, ya, xb, yb, xc, yc. We place the coordinate system so that:  xa = -xb, ya = yb, yc = -2*ya. This will allow us to
define tower positions with only 3 numbers. If the base plate is done precisely then it will be the same as the
firmware defaults computed from DELTA_RADIUS (see how tower positions are computed from delta radius
in Configuration.h).
   [wxMaxima: comment end   ] */

/* [wxMaxima: comment start ]
Define your geometry as specified in the firmware here:
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
ir : 297.85 * 80 $
ixa : -117.226916 * 80 $
iya : -67.874818 * 80 $
ixc : -1.059083 * 80 $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
These tower positions and their errors are fixed because of the limitations on how we place our coordinate system.
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
ixb : - ixa $
xb : -xa $
iyb : iya $
yb : ya $
iyc : -2*iya $
yc : -2*ya $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
Equations for the firmware. These equations work with imprecise firmware parammeters which leads to incorrect
z value at heatbed (and also incorrect x and y values - depends on the exact path we are approaching the
heatbed). We need these equations to get ta,tb,tc from them but we are not going to really use them since
firmware will report ta, tb, tc directly when we query the current position (M114)). Here they are just for reference.
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
Acur : (ix-ixa)^2 + (iy-iya)^2 + (iz-ta)^2 - ir^2 = 0 $
Bcur : (ix-ixb)^2 + (iy-iyb)^2 + (iz-tb)^2 - ir^2 = 0 $
Ccur : (ix-ixc)^2 + (iy-iyc)^2 + (iz-tc)^2 - ir^2 = 0 $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
Equations for precise towerPositions/diagonalRod with carriage positions on towers (ta,tb,tc) adjusted by
offsets (α,β,γ). These equations are valid when the head is at the heatbed (z=0).
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
A : (x-xa)^2 + (y-ya)^2 + (ta+α)^2 - r^2 = 0 $
B : (x-xb)^2 + (y-yb)^2 + (tb+β)^2 - r^2 = 0 $
C : (x-xc)^2 + (y-yc)^2 + (tc+γ)^2 - r^2 = 0 $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
Lets precisely tie (r,xa,xb,xc,ya,yb,yc,α,β,γ) for one (ta,tb,tc) representing one point on heatbed.
We do it by getting rid of x and y.
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
XEq : solve([A-B], [x]) ;
YEq : solve([A+B-2*C], [y]) ;
ZEq : subst( rhs(XEq[1]), x, subst(rhs(YEq[1]), y, C) ) ;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
Now we will measure errors in at least 7+1 positions (x,y).
The best points are the center, near each tower base, and most far away from each tower base. Select the
non-center points as far away from the center as possible. These are the first 7 points. Add one more point
which is far from the other 7 points and not at the same radius (e.g. between two adjacent points at bed edge
but at half the radius). The measurement will be done by touching printhead with the heatbed at these points
and reading out the carriage positions on towers as reported by the firmware (ta,tb,tc).
E.g. if you have a square bed then instead of one additional point add 4 of them - one for each square bed
corner. You can add more points or you can measure each point more than once. But based on Dejay Rezme's
simulations at least 8 (=7+1) distinct points are needed to achieve a good convergence.
You can use any unit you like but the same unit must be used everywhere. If you are using Marlin then
you will probably enter data in millimeters. If you are using Repetier then you will probably use steps.
The measurements below are in steps. One block of numers represents one measurement point. The first
point was measured 3 times, the other points were measured 2 times. A square bed was probed. The probe
points were: centre, tower A base, opposite of tower C, tower B base, opposite of tower A, tower C base,
opposite of tower B, bottom left corner, bottom right corner, top right corner, top left corner.
The data format is [[ta,tb,tc]]. Define the measured data here:
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
m :
[[20962,21836,22854], [23861,20493,15284], [19233,17165,24329], [19142,24302,15771],
[22199,23024,19513], [21757,18999,23388], [15713,22579,22520], [24072,19814,15002],
[23826,20452,19893], [22254,23077,17831], [23700,20305,20549], [22692,22692,17865],
[21062,20153,23543], [22686,22686,18749], [23575,21065,20058], [22579,22579,15758],
[23745,19414,20937], [24474,18362,16530], [23147,21474,20817], [24083,18858,20088],
[23681,16150,21089], [15072,22145,22807], [23712,18377,21231], [16684,22439,22795],
[13699,20352,23666], [20635,20635,23558], [18045,23457,21660], [21305,18477,23663],
[23607,21102,15498], [21969,22802,20873], [14746,20149,23890], [22657,22657,16874],
[21840,20053,23167], [16817,24134,19968], [20103,23528,21102], [16152,23683,21026],
[19201,22767,22524], [22258,17548,23067], [23420,21769,17768], [23929,16516,20593],
[24343,19193,16898], [18313,22029,23218], [17659,23164,22089], [21744,21744,22466],
[22936,22108,20239], [19768,24033,19633], [22140,22968,15722], [21082,17153,23758],
[15656,19895,24070], [20054,21841,23153], [14332,21657,23048], [21217,23708,17601],
[21611,23274,20151], [23068,19559,22137], [20499,12474,23444], [18791,22425,22897],
[17155,21084,23731], [17349,24502,17858], [19618,19618,24063], [23715,21224,17637],
[22411,22411,20900], [18532,20457,23975], [21707,23363,19434], [24557,17423,17072],
[17883,20794,23872], [17786,18814,24377], [23538,19158,21472], [21834,20960,22859],
[23045,22221,16852], [23072,22248,18727], [17888,19878,24165], [19892,24133,16110],
[22976,21289,21399], [20569,23925,16383], [22638,22638,19544], [19610,21435,23472],
[21109,13473,23292], [19011,19011,24250], [19615,23907,20297], [22963,16268,22239],
[18475,21303,23640], [20152,21061,23534], [22032,18316,23250], [20727,23274,21265],
[17214,20226,24064], [23934,20578,16434], [23445,20919,20706], [20226,17214,24085],
[19927,24162,18068], [24340,19188,17836], [19556,23065,22104], [23393,15717,21531],
[20603,23954,18312], [22630,21789,21462], [18336,18336,24402], [18343,24457,17406],
[21095,23600,15457], [16084,22002,23079], [24040,19775,19683], [22155,19456,23066],
[21286,22146,22439], [21655,14330,23097], [24143,19902,16173], [22504,19854,22699],
[23286,18845,21947], [22147,21287,22447], [21054,22760,21904], [22991,18476,22370],
[22762,21056,21922], [23057,15203,21918], [24292,19127,18668], [17547,22257,23029],
[23710,21217,18535], [24211,18007,19778], [20197,22805,22259], [20521,16452,23949],
[16452,20521,23921], [23594,17157,21426], [23681,21184,16632], [16458,19591,24213],
[23961,20610,18356], [15201,23055,21855], [21754,13098,22788], [21582,17769,23524],
[23065,20490,21816], [23462,18050,21712], [22547,22547,20258], [16744,23298,21801],
[18042,22646,22702], [22806,21973,20885], [23842,17502,20939], [19857,23319,21632],
[18351,24463,16446], [21209,12148,22984], [19155,23535,21429], [24125,19880,18946],
[23366,21710,19454], [18209,24358,14118], [22440,16685,22841], [23662,21163,19336],
[24241,19060,14648], [22646,18042,22739], [12152,21213,22930], [23914,19622,20345],
[22769,19203,22556], [20148,14745,23924], [18284,24414,18263], [24209,19020,19418],
[22238,13905,22542], [21432,19607,23483], [20488,23063,21791], [16330,21321,23545],
[17373,24518,14872], [24047,17783,20390], [17152,23589,21366], [19185,24335,16829],
[18472,22987,22328], [19933,24167,17146], [21817,16979,23346], [18171,24331,19028],
[21158,23657,19304], [22220,23044,16841], [19012,24201,19357], [20917,23443,20679],
[18486,19475,24228], [24313,19153,15847], [21764,23415,17744], [24531,17386,14978],
[23277,21614,20171], [24171,19936,18124], [19590,16457,24233], [20609,23959,17404],
[18370,23705,21176], [17053,24297,19341], [21728,23382,16747], [20459,18534,23991],
[20066,19109,24046], [24426,17237,18721], [19802,24060,14932], [21287,22974,21381],
[19047,24228,14564], [20348,13695,23705], [18843,23284,21906], [22014,22014,22002],
[21320,16329,23580], [18853,24078,20032], [24370,18221,14215], [13099,21755,22729],
[23534,20109,21140], [15588,20765,23736], [16266,22961,22184], [17205,22824,22465],
[19177,24329,17768], [12478,20503,23397], [24338,18178,19098], [23311,21650,15647],
[24299,17055,19414], [22575,15709,22568], [24440,18316,15448], [22105,22933,20227],
[23386,21732,16772], [22825,17206,22511], [24422,18292,18336], [22423,18789,22925],
[21562,22411,21975], [18998,21756,23366], [24563,17432,16091], [21210,23703,18500],
[21061,23571,20028], [16979,21817,23310], [21427,21427,22879], [20158,20158,23833],
[18003,24207,19714], [24177,19943,17206], [21056,21056,23241], [17413,24547,16982],
[22248,23072,18718], [20301,23696,20512], [24137,16820,20039], [23966,20616,17450],
[20976,19105,23760], [21759,23411,18636], [21177,23674,16594], [20795,17884,23894],
[15716,23392,21467], [18638,23912,20635], [22195,20441,22802], [20594,19662,23816],
[19411,23742,20894], [20585,21475,23218], [19872,24117,18893], [19662,20594,23809],
[17498,23838,20878], [16517,23930,20528], [23301,16747,21858], [18306,24430,15360],
[22234,22234,21479], [17421,24552,15994], [22806,20198,22283], [22500,20772,22386],
[17231,24420,18642], [20764,15587,23771], [21475,20585,23225], [23919,18645,20691],
[20482,23850,15228], [22002,16084,23123], [19878,17888,24179], [17771,21584,23497],
[24468,18354,17486], [17778,24042,20327], [19118,24283,18604], [19475,18486,24235],
[20962,14606,23555], [23322,19860,21666], [20772,22500,22371], [22144,15071,22858],
[23166,17661,22137], [22412,21563,21983], [13475,21111,23243], [21646,23307,15621],
[19854,22504,22676], [23415,21763,18658], [20549,23908,19125], [20439,22193,22785],
[14606,20962,23512], [18813,17785,24383], [22969,22141,15733], [23276,20729,21291],
[21473,23146,20800], [23081,22258,17844], [24511,17358,17943], [21509,15393,23358],
[19457,22156,23045], [17164,19232,24315], [23027,22202,19525], [19109,20066,24039],
[20449,23823,19856], [13909,22242,22486], [21789,22630,21454], [23915,20556,19167],
[22671,14601,22252], [19103,20974,23744], [19895,15656,24098], [15396,21512,23318],
[14604,22674,22195]] $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
Set your z-probe height. The probe measure point must be just below the tip; i.e. its (x,y) offset must be (0,0).
But it can have nonzero height. If you know the height then set its value here. If you do not know it set it to 0.
It does not really matter if it is not set precisely. The only consequence of incorrectly set probe height is that
your all your computed tower endstop adjustements (α,β,γ) will be uniformly offset by the probe height error.
In this case the z-probe height is 868 steps. Set your own value here:
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
ph : 868 - 33 $ 
mm : map( lambda([lst], [ lst[1]-ph, lst[2]-ph, lst[3]-ph ]), m) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: section start ]
MINPACK Version
   [wxMaxima: section end   ] */

/* [wxMaxima: comment start ]
And finally we just need to find [xa,ya,xc,α,β,γ] which will minimize sum of squares of ZEq over mm.
This section uses minpack to do it. The next section does the same using lbfgs. Both options lead to
the same result but this minpack version does not need to fiddle that much with the termination
condition. Read the lbfgs section comments for more discussion about why we do not optimize
also the diagonal rod length.
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
define( ZFn(ta,tb,tc), lhs(ZEq) ) ;
ZFns : map( lambda([args], apply(ZFn, args)), mm ) $
ZFnsSansR : map( lambda([arg], subst(ir,r,arg)), ZFns ) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: hide output   ] */
/* [wxMaxima: input   start ] */
load(minpack) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
RV : minpack_lsquares( ZFns, [r,xa,ya,xc,α,β,γ], [ir,ixa,iya,ixc,0,0,0] ) ;
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
RV_r : minpack_lsquares( ZFnsSansR, [xa,ya,xc,α,β,γ], [ixa,iya,ixc,0,0,0] ) ;
positionErr_r : sqrt(sqrt(RV_r[2]/length(m))) ;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
RV : minpack_lsquares( ZFns, [r,xa,ya,xc,α,β,γ], [ir,ixa,iya,ixc,0,0,0] ) ;
positionErr : sqrt(sqrt(RV[2]/length(m))) ;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: section start ]
LBFGS Version
   [wxMaxima: section end   ] */

/* [wxMaxima: comment start ]
We define function FAll which is sum of squares of ZEq over all the measured data points. This the error
function we want to minimize. If we can get it to zero for some vector [r,xa,ya,xc,α,β,γ], then that vector
should represent the precise firmware configuration parameters.
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
define( ZFnSq(ta, tb, tc), lhs(ZEq)^2 ) ;
define( ZFnSq1(r,xa,ya,xc,α,β,γ), ''( funmake(ZFnSq,mm[1]) ) ) $
define( FAll(r,xa,ya,xc,α,β,γ), ''( lsum( funmake(ZFnSq,l), l, mm ) ) ) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
OK, and here we go to find the best firmware parameters (r, xa, ya, xc, α, β, γ). We will do it by minimizing FAll.
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
load( lbfgs ) $
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
A quick note about lbfgs(F, x, x0, ε, printFlags) failures. It is a newton like method for finding an extreme.
So it goes along gradient till the gradient is not small enough. The small enough is defined like this:
|∇F(x)| < ε*max(1,|x|)
So (for the algorithm to finish) the gradient change must be really small if also the point x (at which we are
computing F) is small (near the coordinate centre). If the condition on gradient size is really tough then the
line search may fail (maybe because of underflow, or maybe because there is no extreme near the x or
maybe something else). Slowly increase the value of  ε (the second to the last) argument of lbfsg untill it
finds something. The best ε is the smallest one for which a result is found.
   [wxMaxima: comment end   ] */

/* [wxMaxima: comment start ]
Here we compute all the precise parameters at once. This should work without problems if the heatbed is
planar, the additional point was properly selected, and the z-heights were measured near enough the edge
of the available built volume (for the points which should be at the edges). That means the heatbed must
be big enough to extend to the theoretical edge of the built area. If so then we should get the correct
firmware parameters in one step. The equation should have at most two real minimums. One corresponing
to the diagonal rods pointing down and small absolute values of  (α,β,γ) and, possibly, one more
corresponding to the diagonal rods poining up and huge absolute values of  (α,β,γ). Since our starting
point has α=β=γ=0 we should get to the proper minimum. There were no convergence problems with
the 11 points we selected.
A posible reason for bad convegence is that we try to optimize both the tower positions and the diagonal
rod length at once. The tower positions contain the delta radius (corrected for tower radial/diagonal distance
errors if the towers are not precisely positioned). Both errors in the diagonal rod length and the delta radius
lead to nicely concave/convex heatbed z-position error near the centre (looks like a tip of ellipsoid or
paraboloid). These two can partialy compensate for each other especially when measurements are not
done far enough from centre. That means that their convergence (when optimized and the measurement
points are not far enough from the centre) together may be poor. They can drift from their precise values
together more easily. This drift will result in incorrect size (well and also incorrect shape because the error
is not linear) of the printed objects. Incorrect steps/mm setting for the tower carriages results in a similar
kind of error too.
   [wxMaxima: comment end   ] */

/* [wxMaxima: comment start ]
RV : lbfgs( FAll(r,xa,ya,xc,α,β,γ), [r,xa,ya,xc,α,β,γ], [ir,ixa,iya,ixc,0,0,0], 20.0, [1,1]);
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
RVr :  lbfgs( FAll(ir,xa,ya,xc,α,β,γ), [xa,ya,xc,α,β,γ], [ixa,iya,ixc,0,0,0], 15.0, [1,1]) ;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
RVes :  lbfgs( FAll(ir,ixa,iya,ixc,α,β,γ), [α,β,γ], [0,0,0], 1.0, [1,1]) ;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
[ixa, iya, ixc];
/* [wxMaxima: input   end   ] */

/* Maxima can't load/batch files which end with a comment! */
"Created with wxMaxima"$
